## 完整工作流程：获取实验室列表

### 流程图概览

```
HTTP GET 请求 
  ↓
Flask 路由接收
  ↓
检查 Redis 缓存
  ├─ 缓存命中 → 直接返回
  └─ 缓存未命中 ↓
      查询数据库
        ↓
      Schema 序列化
        ↓
      存入 Redis 缓存
        ↓
      返回 JSON 响应
```

### 第 1 步：HTTP 请求到达

客户端发送请求：
```http
GET /api/v1/laboratory/
```

### 第 2 步：Flask 路由匹配

```py
def get_labs():
    """获取所有实验室（带缓存）"""
    try:
        # 尝试从缓存获取序列化后的数据
        cache_key = 'api:lab:list'
        cached_data = redis_client.get(cache_key)
        if cached_data is not None:
            # 缓存命中，直接返回（完全跳过数据库查询和序列化）
            return success(data=cached_data, msg='查询成功')
        
        # 缓存未命中，查询数据库并序列化
        labs = lab_service.get_lab_list()
        data = lab_schema.dump(labs, many=True)
        
        # 存入缓存（10分钟过期）
        redis_client.set(cache_key, data, ex=600)
        
        return success(data=data, msg='查询成功')
    except Exception as e:
        return fail(code=500, msg=f'查询失败: {str(e)}')
```

### 第 3 步：检查 Redis 缓存

```python
cache_key = 'api:lab:list'
cached_data = redis_client.get(cache_key)
```

内部执行：

```py
    def get(self, key: str, default: Any = None) -> Any:
        """
        获取键值
        
        Args:
            key: 键名
            default: 默认值
        
        Returns:
            值（会自动反序列化）
        """
        try:
            value = self.redis_client.get(key)
            if value is None:
                return default
            
            # 尝试解析 JSON
            try:
                return json.loads(value)
            except (json.JSONDecodeError, TypeError):
                return value
        except Exception as e:
            current_app.logger.error(f'Redis get 失败: {e}')
            return default
```

执行过程：
1. `self.redis_client.get('api:lab:list')` 从 Redis 读取
2. 如果返回 `None`，表示缓存未命中，返回 `default`（`None`）
3. 如果有值，尝试 `json.loads()` 反序列化
4. 返回 Python 对象（字典或列表）

### 第 4 步：缓存命中分支（快速路径）

```python
if cached_data is not None:
    return success(data=cached_data, msg='查询成功')
```

`success()` 函数：

```py
def success(data: Any = None, msg: str = 'success') -> tuple:
    """
    成功响应
    
    Args:
        data: 响应数据
        msg: 响应消息
    
    Returns:
        (response, status_code) 元组
    """
    response = {
        'code': 200,
        'msg': msg,
        'data': data
    }
    return jsonify(response), 200
```

返回：
```json
{
  "code": 200,
  "msg": "查询成功",
  "data": [
    {"id": 1, "name": "计算机实验室", "location": "教学楼A101"},
    {"id": 2, "name": "物理实验室", "location": "教学楼B202"}
  ]
}
```

### 第 5 步：缓存未命中分支（完整流程）

#### 5.1 查询数据库

```python
labs = lab_service.get_lab_list()
```

Service 层：

```py
def get_lab_list():
    """
    查询所有实验室
    
    Returns:
        list: 实验室对象列表
    """
    labs = Laboratory.query.all()
    return labs
```

执行：
- `Laboratory.query.all()` 执行 SQL：`SELECT * FROM laboratory`
- 返回 `List[Laboratory]`（SQLAlchemy ORM 对象列表）

示例数据：
```python
labs = [
    <Laboratory 1: 计算机实验室>,  # ORM 对象
    <Laboratory 2: 物理实验室>    # ORM 对象
]
```

#### 5.2 Schema 序列化

```python
data = lab_schema.dump(labs, many=True)
```

调用链：

```python
lab_schema.dump(labs, many=True)
  ↓
BaseSchema.dump()  # 重写的方法
  ↓
super().dump()  # marshmallow.Schema.dump()
  ↓
返回字典列表（可能包含 None）
  ↓
_filter_none()  # 过滤 None 值
  ↓
返回最终结果
```

详细过程：

```py
    def dump(self, obj, *, many=None, **kwargs):
        """
        重写 dump 方法，自动过滤 None 值
        
        Args:
            obj: 要序列化的对象
            many: 是否为多个对象
            **kwargs: 其他参数
        
        Returns:
            序列化后的字典，自动过滤 None 值
        """
        result = super().dump(obj, many=many, **kwargs)
        
        # 递归过滤 None 值
        if many:
            return [self._filter_none(data) for data in result]
        else:
            return self._filter_none(result)
```

转换过程：
```python
# 输入：ORM 对象列表
labs = [<Laboratory 1>, <Laboratory 2>]

# 经过 marshmallow 序列化
result = [
    {'id': 1, 'name': '计算机实验室', 'location': '教学楼A101'},
    {'id': 2, 'name': '物理实验室', 'location': None}  # 包含 None
]

# 经过 _filter_none 过滤
data = [
    {'id': 1, 'name': '计算机实验室', 'location': '教学楼A101'},
    {'id': 2, 'name': '物理实验室'}  # None 被过滤
]
```

#### 5.3 存入 Redis 缓存

```python
redis_client.set(cache_key, data, ex=600)
```

内部执行：

```py
    def set(self, key: str, value: Any, ex: Optional[int] = None) -> bool:
        """
        设置键值对
        
        Args:
            key: 键名
            value: 值（会自动序列化）
            ex: 过期时间（秒）
        
        Returns:
            bool: 是否设置成功
        """
        try:
            if isinstance(value, (dict, list)):
                value = json.dumps(value, ensure_ascii=False)
            return self.redis_client.set(key, value, ex=ex)
        except Exception as e:
            current_app.logger.error(f'Redis set 失败: {e}')
            return False
```

执行过程：
1. 判断 `value` 是否为字典或列表
2. 使用 `json.dumps()` 序列化为 JSON 字符串
3. 调用 `self.redis_client.set('api:lab:list', json_string, ex=600)`
4. Redis 存储，10 分钟后自动过期

Redis 存储内容：
```
Key: api:lab:list
Value: [{"id":1,"name":"计算机实验室","location":"教学楼A101"},{"id":2,"name":"物理实验室"}]
TTL: 600 秒
```

#### 5.4 返回响应

```python
return success(data=data, msg='查询成功')
```

与缓存命中路径相同，返回标准 JSON 响应。

### 第 6 步：异常处理

```python
except Exception as e:
    return fail(code=500, msg=f'查询失败: {str(e)}')
```

`fail()` 函数：

```py
def fail(code: int = 400, msg: str = '操作失败', data: Any = None) -> tuple:
    """
    失败响应
    
    Args:
        code: HTTP 状态码
        msg: 错误消息
        data: 额外的错误数据（可选）
    
    Returns:
        (response, status_code) 元组
    """
    response = {
        'code': code,
        'msg': msg
    }
    if data is not None:
        response['data'] = data
    return jsonify(response), code
```

返回错误响应：
```json
{
  "code": 500,
  "msg": "查询失败: 数据库连接错误"
}
```

## 完整数据流转图

```
HTTP 请求
  ↓
Flask 路由: get_labs()
  ↓
Redis.get('api:lab:list')
  ├─ 命中: 返回 JSON 字符串
  │    ↓
  │  json.loads() → Python 字典
  │    ↓
  │  success() → JSON 响应 ✅
  │
  └─ 未命中: 返回 None
       ↓
    lab_service.get_lab_list()
       ↓
    Laboratory.query.all()
       ↓
    SQL 查询 → List[Laboratory] (ORM 对象)
       ↓
    lab_schema.dump(labs, many=True)
       ↓
    marshmallow 序列化 → List[Dict] (可能含 None)
       ↓
    _filter_none() → List[Dict] (过滤 None)
       ↓
    redis_client.set(key, data, ex=600)
       ↓
    json.dumps() → JSON 字符串
       ↓
    Redis 存储 (TTL: 600秒)
       ↓
    success() → JSON 响应 ✅
```